package autoexploit

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

// ExploitPayload represents a discovered XSS payload for exploitation
 type ExploitPayload struct {
	URL      string
	Payload  string
	Context  string // e.g. "reflected", "dom", "stored"
	Method   string // GET, POST, etc.
	PostData string // For POST/JSON/XML
	Headers  map[string]string
	Cookies  string
}

// PoCFormats supported for export
var PoCFormats = []string{"html", "curl", "fetch", "python", "powershell"}

// GenerateBrowserPoC generates a browser-based PoC (HTML/JS) for the payload
func GenerateBrowserPoC(ep ExploitPayload) string {
	return fmt.Sprintf(`<!DOCTYPE html><html><body><a href="%s">Click me</a><script>window.open('%s')</script></body></html>`, ep.URL, ep.URL)
}

// GenerateCurlPoC generates a curl command PoC for the payload
func GenerateCurlPoC(ep ExploitPayload) string {
	cmd := fmt.Sprintf(`curl -X %s "%s"`, ep.Method, ep.URL)
	if ep.Cookies != "" {
		cmd += fmt.Sprintf(" -b '%s'", ep.Cookies)
	}
	for k, v := range ep.Headers {
		cmd += fmt.Sprintf(" -H '%s: %s'", k, v)
	}
	if ep.Method == "POST" && ep.PostData != "" {
		cmd += fmt.Sprintf(" -d '%s'", ep.PostData)
	}
	return cmd
}

// GenerateFetchPoC generates a JS fetch PoC
func GenerateFetchPoC(ep ExploitPayload) string {
	headers := []string{}
	for k, v := range ep.Headers {
		headers = append(headers, fmt.Sprintf("'%s': '%s'", k, v))
	}
	return fmt.Sprintf(`fetch('%s', { method: '%s', headers: { %s }, body: %s, credentials: 'include' });`, ep.URL, ep.Method, strings.Join(headers, ", "), jsonString(ep.PostData))
}

// GeneratePythonPoC generates a Python requests PoC
func GeneratePythonPoC(ep ExploitPayload) string {
	return fmt.Sprintf(`import requests\nheaders = %s\nr = requests.request('%s', '%s', headers=headers, data=%s, cookies=%s)\nprint(r.text)`,
		jsonMap(ep.Headers), ep.Method, ep.URL, jsonString(ep.PostData), jsonString(ep.Cookies))
}

// GeneratePowershellPoC generates a PowerShell PoC
func GeneratePowershellPoC(ep ExploitPayload) string {
	return fmt.Sprintf(`Invoke-WebRequest -Uri '%s' -Method %s -Headers %s -Body '%s' -UseBasicParsing`,
		ep.URL, ep.Method, jsonMap(ep.Headers), ep.PostData)
}

// ExportPoCs exports all PoC formats to files
func ExportPoCs(ep ExploitPayload, dir string) error {
	os.MkdirAll(dir, 0755)
	pocs := map[string]string{
		"html":       GenerateBrowserPoC(ep),
		"curl":       GenerateCurlPoC(ep),
		"fetch":      GenerateFetchPoC(ep),
		"python":     GeneratePythonPoC(ep),
		"powershell": GeneratePowershellPoC(ep),
	}
	for ext, content := range pocs {
		f := fmt.Sprintf("%s/poc.%s", dir, ext)
		os.WriteFile(f, []byte(content), 0644)
	}
	return nil
}

// AutoExploit tries to exploit the payload in available headless browsers (Chrome/Firefox)
func AutoExploit(ep ExploitPayload) error {
	browsers := []string{"chromium-browser", "google-chrome", "chrome", "firefox"}
	var found string
	for _, b := range browsers {
		if path, err := exec.LookPath(b); err == nil {
			found = path
			break
		}
	}
	if found == "" {
		return fmt.Errorf("No supported headless browser found (install Chrome or Firefox)")
	}
	var args []string
	if strings.Contains(found, "firefox") {
		args = []string{"--headless", ep.URL}
	} else {
		args = []string{"--headless", "--disable-gpu", "--dump-dom", ep.URL}
	}
	cmd := exec.Command(found, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("exploit failed: %v\n%s", err, string(output))
	}
	fmt.Println("Exploit output:\n", string(output))
	return nil
}

// Helper: convert map to JSON
func jsonMap(m map[string]string) string {
	b, _ := json.Marshal(m)
	return string(b)
}

// Helper: convert string to JSON string
func jsonString(s string) string {
	b, _ := json.Marshal(s)
	return string(b)
}

